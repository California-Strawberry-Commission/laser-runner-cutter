<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Receiver Test - Fixed</title>
    <style>
        body { 
            font-family: sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center;
            background: #f0f0f0;
        }
        video { 
            width: 640px; 
            height: 480px; 
            background-color: #333; 
            border: 2px solid #444; 
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #status {
            padding: 10px 20px;
            border-radius: 20px;
            background: #fff;
            margin: 10px;
            font-weight: bold;
        }
        #status.connected { background: #4CAF50; color: white; }
        #status.connecting { background: #FF9800; color: white; }
        #status.error { background: #F44336; color: white; }
        pre { 
            background-color: #222; 
            color: #0f0;
            padding: 10px; 
            border-radius: 5px; 
            width: 640px; 
            max-height: 200px; 
            overflow-y: scroll; 
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .stats {
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px;
            width: 640px;
        }
    </style>
</head>
<body>
    <h1>WebRTC Receiver Test</h1>
    <video id="remoteVideo" autoplay playsinline muted></video>
    <p id="status" class="connecting">Connecting...</p>
    <div class="stats">
        <div>Frames Received: <span id="framesReceived">0</span></div>
        <div>Bitrate: <span id="bitrate">0</span> kbps</div>
        <div>Connection State: <span id="connState">new</span></div>
    </div>
    <h3>Console Output:</h3>
    <pre id="log"></pre>

    <script>
        const logElement = document.getElementById('log');
        function log(message, level = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const prefix = level === 'error' ? 'ERROR' : level === 'warn' ? 'WARN' : 'SUCCESS';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(message);
        }

        const videoElement = document.getElementById('remoteVideo');
        const statusElement = document.getElementById('status');

        const MY_PEER_ID = 456;
        const SIGNALING_SERVER_URL = `ws://${window.location.hostname}:8081`;

        let pc = null;
        let ws = null;
        let statsInterval = null;

        async function startWebRTC() {
            log('Starting WebRTC setup...');

            ws = new WebSocket(SIGNALING_SERVER_URL);

            ws.onopen = () => {
                log('WebSocket connected. Sending HELLO...');
                ws.send(`HELLO ${MY_PEER_ID}`);
                statusElement.textContent = 'WebSocket connected';
                statusElement.className = 'connecting';
            };

            ws.onmessage = async (event) => {
                const message = event.data;
                log(`Received: ${message.substring(0, 50)}...`);

                if (message.startsWith('HELLO_ACK')) {
                    log('Registration confirmed');
                    return;
                } else if (message.startsWith('ERROR')) {
                    log(`Server error: ${message}`, 'error');
                    statusElement.textContent = `Error: ${message}`;
                    statusElement.className = 'error';
                    return;
                }

                try {
                    const data = JSON.parse(message);

                    if (data.sdp) {
                        await handleSDP(data.sdp);
                    } else if (data.ice) {
                        await handleICE(data.ice);
                    }
                } catch (e) {
                    log(`Error processing message: ${e.message}`, 'error');
                }
            };

            ws.onclose = () => {
                log('WebSocket disconnected', 'warn');
                statusElement.textContent = 'WebSocket disconnected';
                statusElement.className = 'error';
                if (pc && pc.connectionState !== 'closed') {
                    pc.close();
                }
                stopStatsMonitoring();
            };

            ws.onerror = (error) => {
                log(`WebSocket error: ${error}`, 'error');
                statusElement.textContent = 'WebSocket error';
                statusElement.className = 'error';
            };
        }

        async function handleSDP(sdp) {
            log(`Processing SDP ${sdp.type}`);

            if (sdp.type === 'offer') {
                if (!pc) {
                    createPeerConnection();
                }

                await pc.setRemoteDescription(new RTCSessionDescription(sdp));
                log('Remote description set');

                const answer = await pc.createAnswer();
                
                answer.sdp = answer.sdp.replace(/a=recvonly/g, 'a=sendrecv');
                
                await pc.setLocalDescription(answer);
                ws.send(JSON.stringify({ sdp: answer }));
                log('Answer sent');
            }
        }

        async function handleICE(ice) {
            if (!pc) {
                log('Received ICE before peer connection ready', 'warn');
                return;
            }

            try {
                await pc.addIceCandidate(new RTCIceCandidate(ice));
                log('ICE candidate added');
            } catch (e) {
                log(`Failed to add ICE candidate: ${e.message}`, 'warn');
            }
        }

        function createPeerConnection() {
            log('Creating RTCPeerConnection');
            
            const config = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' }
                ],
                sdpSemantics: 'unified-plan'
            };

            pc = new RTCPeerConnection(config);

            pc.ontrack = (event) => {
                log(`Track received: ${event.track.kind} (id: ${event.track.id})`);
                
                if (event.track.kind === 'video') {
                    if (videoElement.srcObject !== event.streams[0]) {
                        videoElement.srcObject = event.streams[0];
                        log('Video stream attached to element');
                    }

                    event.track.onmute = () => log('Track muted', 'warn');
                    event.track.onunmute = () => log('Track unmuted');
                    event.track.onended = () => log('Track ended', 'warn');
                    
                    startStatsMonitoring();
                }
            };

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({ 
                        ice: {
                            candidate: event.candidate.candidate,
                            sdpMLineIndex: event.candidate.sdpMLineIndex
                        }
                    }));
                    log('Local ICE candidate sent');
                } else {
                    log('ICE gathering complete');
                }
            };

            pc.oniceconnectionstatechange = () => {
                log(`ICE state: ${pc.iceConnectionState}`);
                document.getElementById('connState').textContent = pc.iceConnectionState;
                
                if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                    statusElement.textContent = 'Connected!';
                    statusElement.className = 'connected';
                } else if (pc.iceConnectionState === 'failed') {
                    statusElement.textContent = 'Connection failed';
                    statusElement.className = 'error';
                }
            };

            pc.onconnectionstatechange = () => {
                log(`Connection state: ${pc.connectionState}`);
                if (pc.connectionState === 'connected') {
                    log('WebRTC fully connected!');
                }
            };

            pc.addTransceiver('video', { direction: 'recvonly' });
            log('Video transceiver added');
        }

        function startStatsMonitoring() {
            if (statsInterval) return;
            
            statsInterval = setInterval(async () => {
                if (!pc) return;
                
                const stats = await pc.getStats();
                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        document.getElementById('framesReceived').textContent = report.framesReceived || 0;
                        
                        if (report.bytesReceived) {
                            const bitrate = Math.round((report.bytesReceived * 8) / 1000);
                            document.getElementById('bitrate').textContent = bitrate;
                        }
                    }
                });
            }, 1000);
        }

        function stopStatsMonitoring() {
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
        }

        window.onload = startWebRTC;
    </script>
</body>
</html>